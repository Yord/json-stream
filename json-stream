#!/usr/bin/env node

const os = require('os')
const path = require('path')

try {
  require(path.join(os.homedir(), '.fxrc')) // Should be required before config.js usage.
} catch (err) {
  if (err.code !== 'MODULE_NOT_FOUND') {
    throw err
  }
}

const argv = require('yargs')
  .usage('Usage: $0 [options]')
  
  .alias('f', 'function')
  .nargs('f', 1)
  .describe(
    'f',
    'A JavaScript function on each parsed json "json => ..." that\n'+
    '(1) drops the json if it returns undefined or throws an error,\n'+
    '(2) returns each element as a line if it returns an array,\n'+
    '(3) or returns one line if it returns any other value.'
  )
  
  .alias('r', 'replacer')
  .nargs('r', 1)
  .describe(
    'r',
    'A replacer as defined by the JSON.stringify function'
  )
  
  .alias('s', 'spaces')
  .nargs('s', 1)
  .describe(
    's',
    'The number of spaces used to format json or 0 for one line'
  )
  
  .alias('b', 'bulk-parsing')
  .boolean('b')
  .describe(
    'b',
    'Activates parsing bulks of json objects, which is faster, but fails '+
    'the whole bulk instead of a single JSON object if an error is thrown'
  )

  .example(
    'Pretty printing with 2 spaces:',
    'echo \'{"foo":42}\' |\n'+
    'json-stream -s 2\n\n'+
    '> {\n'+
    '>   "foo": 42\n'+
    '> }\n'
  )
  
  .example(
    'Identity function on each json:',
    'echo \'{"foo":42}\' |\n'+
    'json-stream -f "json => json"\n\n'+
    '> {"foo":42}\n'
  )
  
  .example(
    'Selects the foo attribute:',
    'echo \'{"bar":"baz"}\' |\n'+
    'json-stream -f "json => json.foo"\n'+
    '\n'+
    'nothing is returned since f returns undefined\n'+
    '\n'+
    'echo \'{"foo":["bar","baz"]}\' |\n'+
    'json-stream -f "json => json.foo"\n'+
    '\n'+
    '> bar\n'+
    '> baz\n'+
    '\n'+
    'echo \'{"foo":"bar"}\' |\n'+
    'json-stream -f "json => json.foo"\n'+
    '\n'+
    '> bar'
  )

  .help('h')
  .alias('h', 'help')
  .epilog('(c) Philipp Wille 2019')
  .argv

const f = argv.f && eval(argv.f) || undefined
const spaces = argv.s || 0
const replacer = argv.r && eval(argv.r) || null
const bulkParsing = argv.b || false

process.stdin.setEncoding('utf8')
process.stdin.resume()

function parse (txt) {
  return JSON.parse(txt)
}

let acctxt = ''

process.stdin
.on('data', text => {
  let res      = []
  let txt      = acctxt + text
  let len      = txt.length

  let at       = -1
  
  let escaped  = false
  let string   = false
  let inObj    = false

  let obj      = false
  let brackets = 0

  let done     = false
  let from     = 0
  let ch
  
  do {
    at++
    ch = txt.charAt(at)

    if (string) {
      if (escaped) escaped = false
      else {
        if (ch == '"') string = false
        else if (ch == '\\') escaped = true
      }
    } else {
      if (ch == '"') string = true
      else if (ch == '{') {
        if (brackets == 0) from = at
        inObj = true
        brackets++
      } else if (inObj && ch == '}') {
        brackets--
        if (brackets == 0) {
          inObj = false
          obj = true
        }
      }
    }

    if (at == len) done = true

    if (obj) {
      obj = false
      const objStr = txt.slice(from, at+1)

      try {
        res.push(objStr)
      } catch (e) {
        process.stderr.write(e + '\n')
      }

      txt = txt.slice(at+1, len)
      len = txt.length
      at = -1
    }
  } while (!done)

  acctxt = txt

  let jsonStrs = ''

  if (bulkParsing) {
    let jsonStr = '['
    const resLen = res.length

    if (resLen == 0) jsonStr += ']'
    else if (resLen == 1) jsonStr += res[0] + ']'
    else {
      jsonStr += res[0]

      for(let index = 1; index < resLen; index++) {
        const objStr = res[index]
        jsonStr += ','+objStr
      }

      jsonStr += ']'
    }

    try {
      const objs = parse(jsonStr)
      for(let index = 0; index < objs.length; index++) {
        const obj = objs[index]
        const obj2 = typeof f === 'undefined' ? obj : f(obj)
        if (typeof obj2 !== 'undefined') {
          const jsonStr = JSON.stringify(obj2, replacer, spaces) + '\n'
          jsonStrs += jsonStr
        }
      }
    } catch (e) {
      process.stderr.write(e + '\n')
    }
  } else {
    for(let index = 0; index < res.length; index++) {
      const objStr = res[index]
  
      try {
        const obj = parse(objStr)
        const obj2 = typeof f === 'undefined' ? obj : f(obj)
        if (typeof obj2 !== 'undefined') {
          const jsonStr = JSON.stringify(obj2, replacer, spaces) + '\n'
          jsonStrs += jsonStr
        }
      } catch (e) {
        process.stderr.write(e + '\n')
      }
    }
  }
  
  process.stdout.write(jsonStrs)
})
